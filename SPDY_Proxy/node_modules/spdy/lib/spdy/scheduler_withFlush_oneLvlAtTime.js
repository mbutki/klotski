var spdy = require('../spdy');
var utils = spdy.utils;
var scheduler = exports;

//
// ### function Scheduler (connection)
// #### @connection {spdy.Connection} active connection
// Connection's streams scheduler
//
function Scheduler(connection) {
  this.connection = connection;
  this.priorities = [[], [], [], [], [], [], [], []];
  this._tickListener = this._tickListener.bind(this);
  this._tickListening = false;
  this._tickCallbacks = [];
  this._corked = false;
  this._flush_scheduled = false;
}

//
// ### function create (connection)
// #### @connection {spdy.Connection} active connection
//
exports.create = function create(connection) {
  return new Scheduler(connection);
};

//
// ### function schedule (stream, data)
// #### @stream {spdy.Stream} Source stream
// #### @data {Buffer} data to write on tick
// Use stream priority to invoke callbacks in right order
//
Scheduler.prototype.schedule = function schedule(stream, data) {
  // Ignore data from destroyed stream
  if (stream._spdyState.destroyed)
    return;
  this.scheduleLast(stream, data);
};

//
// ### function scheduleLast (stream, data)
// #### @stream {spdy.Stream} Source stream
// #### @data {Buffer} data to write on tick
// Use stream priority to invoke callbacks in right order
//
Scheduler.prototype.scheduleLast = function scheduleLast(stream, data) {
  var priority = stream._spdyState.priority;
  priority = Math.min(priority, 7);
  priority = Math.max(priority, 0);
  this.priorities[priority].push(data);
};

Scheduler.prototype._tickListener = function tickListener() {
  var priorities = this.priorities;
  var tickCallbacks = this._tickCallbacks;

  this._flush_scheduled = false;
  this._tickListening = false;
  this._tickCallbacks = [];
  //console.log('setting flush sheduled to false');

  ///// Print out prio buffer sizes /////
  /*console.log('flushing data:');
  for (var i = 0; i < 8; i++) {
    var len1 = 0;
    if (priorities[i] !== undefined) {
        len1 = priorities[i].length;
    }    
    console.log('prio:' + i + ' has:' + len1);
  }*/


  var shouldBreak = false;
  var found = false;
  for (var i = 0; i < 8; i++) {
    while (priorities[i].length > 0) {
      if (priorities[i] !== undefined) {
        found = true;
        var next = this.priorities[i].shift();
        var goodFlush = this.connection.write(next);
        //console.log('wrote out prio:' + i + ' return val:' + goodFlush);
        //console.log('buf size:' +this.connection.socket.bufferSize);
        
        if (! goodFlush) {
          //console.log('overflow, setting flush sheduled');
          this._flush_scheduled = true;
          this.connection.socket.once('drain', this._tickListener.bind(this));
          shouldBreak = true;
          break;
        }
      }
    }
    if (found) {
      break;
    }
    if (shouldBreak) {
      shouldBreak = false;
      break;
    }
  }

  // Invoke callbacks
  for (var i = 0; i < tickCallbacks.length; i++)
    tickCallbacks[i]();

  if (this._corked) {
    this.connection.uncork();
    if (this._tickListening)
      this.connection.cork();
    else
      this._corked = false;
  }
};

//
// ### function tick ()
// Add .nextTick callback if not already present
//
Scheduler.prototype.tick = function tick(cb) {
  if (cb)
    this._tickCallbacks.push(cb);
  if (this._tickListening)
    return;

  if (this._flush_scheduled) {
    //console.log('flush tried but already scheduled');
    return;
  }

  this._tickListening = true;

  if (!this._corked) {
    this.connection.cork();
    this._corked = true;
  }
  if (this.connection._spdyState.parser.drained) {
    utils.nextTick(this._tickListener);
  } else {
    this.connection._spdyState.parser.once('drain', this._tickListener);
  }
};
