{
  "name": "radius",
  "version": "0.1.5",
  "description": "RADIUS packet encoding/decoding",
  "author": {
    "name": "Nearbuy Systems",
    "email": "npm@nearbuysystems.com"
  },
  "main": "./lib/radius",
  "repository": {
    "type": "git",
    "url": "git://github.com/nearbuy/node-radius.git"
  },
  "engines": {
    "node": "0.8.x"
  },
  "devDependencies": {
    "nodeunit": "~0.7.4"
  },
  "scripts": {
    "test": "nodeunit test"
  },
  "keywords": [
    "radius"
  ],
  "readme": "# node-radius [![Build Status](https://secure.travis-ci.org/nearbuy/node-radius.png)](http://travis-ci.org/nearbuy/node-radius) - A RADIUS library for node.js\n\nnode-radius is a RADIUS packet encoding/decoding library for node.js written in Javascript. With node-radius you can easily decode received packets, encode packets to send, and prepare responses to received packets. node-radius supports both RADIUS authentication and RADIUS accounting packets. node-radius is designed to be fast and simple, providing both a synchronous and a callback-style asynchronous interface.\n\nnode-radius requires node.js v0.8.0. To install node-radius, simply run `npm install radius` in your project directory.\n\nLet's look at some examples of how to use node-radius:\n\n    var radius = require('radius');\n\n    // ... receive raw_packet from UDP socket\n\n    var decoded = radius.decode({ packet: raw_packet, secret: \"shared_secret\" });\n\n\"decoded\" might look something like this:\n\n    {\n      code: 'Access-Request',\n      identifer: 123,\n      length: 250,\n      attributes: {\n        'NAS-IP-Address': '10.1.2.3',\n        'User-Name': 'jlpicard',\n        'User-Password': 'beverly123',\n        'Vendor-Specific': {\n          'Federation-Starship': 'Enterprise'\n        }\n      }\n    }\n\nTo prepare your response packet, use the encode_response function:\n\n    var response = radius.encode_response({\n      packet: decoded,\n      code: \"Access-Accept\",\n      secret: \"section31\"\n    });\n\nTo prepare a stand-alone packet, try this:\n\n    var packet = radius.encode({\n      code: \"Access-Request\",\n      secret: \"obsidian order\",\n      attributes: [\n        ['NAS-IP-Address', '10.5.5.5'],\n        ['User-Name', 'egarak'],\n        ['User-Password', 'tailoredfit'],\n        ['Vendor-Specific', 555, [['Real-Name', 'arobinson']]]\n      ]\n    });\n\n\n## Method descriptions:\n\n### radius.decode(\\<args>)\n\ndecode takes as input an object with the following fields:\n\n- packet (required): a Buffer containing the raw UDP RADIUS packet (as read off a socket)\n- secret (required): a String containing the RADIUS shared secret\n- callback (optional): if provided, decode will operate asynchronously. The first argument to the callback will be an error, if any, and the second argument will be the decoded packet. If callback is not provided, decode will return the decoded packet synchronously. See the note on asynchronicity near the end of this README.\n\nUsing the dictionaries available, decode parses the raw packet and yields an object representation of the packet. The object has the following fields:\n\n- code: string representation of the packet code (\"Access-Request\", \"Accounting-Response\", etc)\n- identifier: packet identifier number (used for duplicate packet detection)\n- length: RADIUS packet length\n- attributes: an object containing all attributes node-radius knew how to parse. If an attribute is repeated, its value in the \"attributes\" object will become an Array containing each value. Unfortunately the dictionary files do not specify which attributes are repeatable, so if an attribute might be repeated then you need to check if the value in \"attributes\" is a scalar value or an Array.\n- raw_attributes: an array of arrays containing each raw attribute (attribute type and a Buffer containing the attribute value). This is mainly used by node-radius for generating the response packet, and would only be useful to you if you are missing relevant dictionaries and/or want to decode attributes yourself.\n\nHere is an example using the asynchronous interface to decode a packet:\n\n    radius.decode({\n      packet: raw_packet,\n      secret: shared_secret,\n      callback: function(err, decoded) {\n        if (err) throw err;\n        console.log(\"I got a packet!\");\n        console.log(decoded);\n      }\n    });\n\n### radius.encode(\\<args>)\n\nencode takes an object for arguments and returns a Buffer ready to be sent over the wire. The accepted arguments are:\n\n- code (required): string representation of the packet code (\"Access-Request\", \"Accounting-Response\", etc)\n- secret (required): RADIUS shared secret\n- identifier (optional): packet identifer number (defaults to a random number from 0 to 255)\n- attributes (optional): RADIUS attributes you want to add to the packet\n- authenticator (optional): the 16 octet authenticator field (defaults to a random 16 bytes except for \"Accounting-Request\" messages, which sets the authenticator per RFC2866)\n- callback (optional): if provided, encode will operate asynchronously. The first argument to the callback will be an error, if any, and the second argument will be the encoded packet. If callback is not provided, encode will return the encoded packet synchronously. See the note on asynchronicity near the end of this README.\n\nThe attributes will typically be like the following (see above example):\n\n    attributes: [\n      [<attribute name>, <attribute value>],\n      ...\n    ]\n\nIf you want to send attributes that you haven't loaded a dictionary for, you can do:\n\n    attributes: [\n      [<attribute id>, <Buffer>],\n      ...\n    ]\n\nWhere the first item is the numeric attribute id and the second item is just a Buffer containing the value of the attribute (not including length).\n\nYou can specify Vendor-Specific attributes like so:\n\n    attributes: [\n      ['Vendor-Specific', <vendor id>, [\n        [<attribute name>, <attribute value>],\n        [<attribute name>, <attribute value>]\n      ],\n      ...\n    ]\n\nOr if you want each vendor attribute as a separate attribute, try this:\n\n    attributes: [\n      ['Vendor-Specific', <vendor id>, [[<attribute name>, <attribute value>]]],\n      ['Vendor-Specific', <vendor id>, [[<attribute name>, <attribute value>]]]\n      ...\n    ]\n\nLike regular attributes, you can also specify the attribute id and a raw Buffer value for VSAs. If your dictionary specifies vendor attributes using the BEGIN-VENDOR/END-VENDOR format, you can use the symbolic vendor name as defined in the dictionary in place of the numeric \\<vendor id>.\n\nYou can specify the tag field-attribute like so (see RFC2868):\n\n    attributes: [\n      [<attribute name>, <tag number>, <attribute value>],\n      ...\n    ]\n\nIf the attribute has an optional tag and you don't want to send it, then only specify the \\<attribute name> and the \\<attribute value>.\n\nHere is an example using the asynchronous interface, sending the encoded packet using a previously created UDP socket \"dgram_socket\":\n\n    radius.encode({\n      code: \"Accounting-Request\",\n      secret: \"open-sesame\",\n      attributes: [\n        ['NAS-Identifier', 'DS9'],\n        ['User-Name', 'Quark'],\n        ['User-Password', 'profit']\n      ],\n      callback: function(err, encoded) {\n        if (err) throw err;\n        dgram_socket.send(encoded, 0, encoded.length, 1813, '10.8.8.8');\n      }\n    });\n\n\n### radius.encode\\_response(\\<args>)\n\nencode_response prepares a response packet based on previously received and decoded packet. \"args\" is an object with the following properties:\n\n- packet (required): the output of a previous call to radius.decode\n- code (required): String representation of the packet code (\"Access-Reject, \"Accounting-Response\", etc)\n- attributes (optional): RADIUS attributes you want to add to the packet\n- callback (optional): if provided, encode_response will operate asynchronously. The first argument to the callback will be an error, if any, and the second argument will be the encoded packet. If callback is not provided, encode\\_response will return the encoded packet synchronously. See the note on asynchronicity near the end of this README.\n\nencode_response does a few things for you to prepare the response:\n\n1. sets the response packet's message identifier to the identifer of the previously received packet\n1. copies any \"Proxy-State\" attributes from the previously received packet into the response packet\n1. calculates the appropriate response authenticator\n\n## Dictionaries\n\nnode-radius supports reading freeradius-style RADIUS dictionary files. node-radius comes with a slew of RFC dictionary files, so you should only worry about adding any vendor-specific dictionary files you have. node-radius will load all the dictionaries it knows about (the default RFC ones and any you added) automatically the first time it needs to, so you should add your dictionaries before you start to use the module.\n\n### radius.add_dictionary(\\<path>)\n\nTo add a dictionary to be loaded, use the **add_dictionary** function:\n\n    var radius = require('radius');\n\n    radius.add_dictionary('/path/to/my/dictionary');\n\nadd\\_dictionary takes either a file or a directory (given a directory, it assumes everything in the directory is a dictionary file). add\\_dictionary does not block or perform any IO. It simply adds the given path to a list which is used to load dictionaries later.\n\nnode-radius supports reading both the VENDORATTR and the BEGIN-VENDOR/END-VENDOR style for defining VSAs. node-radius also supports reading the following attribute modifiers: has_tag, encrypt=1.\n\nnode-radius will also follow \"$INCLUDE\" directives inside of dictionary files (to load other dictionary files).\n\n## Example usage\n\nThe following is an example of a simple radius authentication server:\n\n    var radius = require('radius');\n    var dgram = require(\"dgram\");\n\n    var secret = 'radius_secret';\n    var server = dgram.createSocket(\"udp4\");\n\n    server.on(\"message\", function (msg, rinfo) {\n      var code, username, password, packet;\n      packet = radius.decode({packet: msg, secret: secret});\n\n      if (packet.code != 'Access-Request') {\n        console.log('unknown packet type: ', packet.code);\n        return;\n      }\n\n      username = packet.attributes['User-Name'];\n      password = packet.attributes['User-Password'];\n\n      console.log('Access-Request for ' + username);\n\n      if (username == 'jlpicard' && password == 'beverly123') {\n        code = 'Access-Accept';\n      } else {\n        code = 'Access-Reject';\n      }\n\n      var response = radius.encode_response({\n        packet: packet,\n        code: code,\n        secret: secret\n      });\n\n      console.log('Sending ' + code + ' for user ' + username);\n      server.send(response, 0, response.length, rinfo.port, rinfo.address, function(err, bytes) {\n        if (err) {\n          console.log('Error sending response to ', rinfo);\n        }\n      });\n    });\n\n    server.on(\"listening\", function () {\n      var address = server.address();\n      console.log(\"radius server listening \" +\n          address.address + \":\" + address.port);\n    });\n\n    server.bind(1812);\n\nClient and server examples can be found in the examples directory.\n\n## Important notes:\n\n- node-radius in general does _not_ perform \"higher-level\" protocol validation, so for example node-radius will not complain if you encode an Access-Request packet but fail to include a NAS-IP-Address or NAS-Identifier.\n- node-radius will never block using the asynchronous, callback-style interface. Using the synchronous interface, node-radius performs two one-time, potentially blocking actions: loading the dictionaries, and generating the first random message authenticator. If you find the synchronous interface convenient, go ahead and use it. The asynchronous interface is there if you really really never want to block, not even just once on startup.\n- node-radius in general assumes most strings are UTF-8 encoded. This will work fine for ASCII and UTF-8 strings, but will not work for other encodings. At some point I might add an \"encoding\" option to override this default encoding, and/or a \"raw\" mode that just deals with Buffers (rather than Strings) when the encoding is not known.\n- node-radius does not support non-standard VSAs (where type or length field for attributes are not one octet each).\n- node-radius does not support special decoding/encoding for the following attribute types: ipv6addr, ifid, ipv6prefix, short. If node-radius encounters a type it doesn't support, node-radius will return a raw Buffer when decoding, and expect a Buffer when encoding.\n- node-radius does not support any password encryption types other than that defined by RFC2865 for User-Password (e.g. does not support Tunnel-Password).\n\nBut, on the plus-side, unlike many other RADIUS libraries node-radius supports encrypting/decrypting passwords longer than 16 bytes!\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/nearbuy/node-radius/issues"
  },
  "_id": "radius@0.1.5",
  "dist": {
    "shasum": "cef18b434e18913a157011b2910b96b64841ba85"
  },
  "_from": "radius@~ 0.1",
  "_resolved": "https://registry.npmjs.org/radius/-/radius-0.1.5.tgz"
}
